#!/bin/sh

# Deploy story-indexer
# Phil Budne, 9/2023
# (from rss-fetcher/dokku-scripts/push.sh 9/2022!)

# deploys from currently checked out branch

# PLB: add -u (untagged deploy, allow unclean repo, from dev branches only)????

# stack name (suffix if not production)
# NOTE! indicates application for peaceful coexistence!!
BASE_STACK_NAME=indexer

SCRIPT=$0
SCRIPT_DIR=$(dirname $SCRIPT)

# hostname w/o any domain
HOSTNAME=$(hostname --short)

if [ "x$(which jinja2)" = x ]; then
    VENV_BIN=$SCRIPT_DIR/../venv/bin
    if [ -x $VENV_BIN/jinja2 ]; then
	. $VENV_BIN/activate
    else
	echo FATAL: cannot find jinja2 1>&2
	exit 3
    fi
fi

usage() {
    echo "Usage: $SCRIPT [options]"
    echo "options:"
    echo "  -d  enable debug output (on jinja2 invocation)"
    echo "  -h  output this help and exit"
    echo "  -n  dry-run: creates docker-compose.yml but does not invoke docker (implies -u)"
    echo "  -u  allow running as non-root user"
    exit 1
}
while getopts dhnu OPT; do
   case "$OPT" in
   d) DEBUG=1;;
   h|'?') usage;;
   n) NO_ACTION=1; AS_USER=1;;
   u) AS_USER=1;;
   esac
done
# XXX complain if anything remaining?

# may not be needed if user is in right (docker?) group(s)?
if [ "x$AS_USER" = x -a $(whoami) != root ]; then
    echo must be run as root 1>&2
    exit 1
fi

# get logged in user (even if su(do)ing)
# (lookup utmp entry for name of tty from stdio)
# will lose if run non-interactively via ssh (no utmp entry)
LOGIN_USER=$(who am i | awk '{ print $1 }')
if [ "x$LOGIN_USER" = x ]; then
    # XXX fall back to whoami (look by uid)
    echo could not find login user 1>&2
    exit 1
fi

if [ "x$NO_ACTION" = x ] && ! git diff --quiet; then
    echo 'local changes not checked in' 1>&2
    # XXX display diffs, or list dirty files??
    exit 1
fi

BRANCH=$(git branch --show-current)
GIT_HASH=$(git rev-parse --short HEAD)

dirty() {
    if [ "x$NO_ACTION" = x ]; then
	echo "$*" 1>&2
	exit 1
    fi
}

# PUSH_TAG_TO: git remotes to push tag to
PUSH_TAG_TO="origin"

# defaults for template variables that might change based on BRANCH/DEPLOY_TYPE
# (in alphabetical order):

ELASTIC_NUM_NODES=1

FETCHER_NUM_BATCHES=10

PLACEMENT_CONSTRAINTS=

STATSD_REALM="$BRANCH"

# XXX run local instance if developer (don't clutter tarbell disk)??
# depends on proxy running on tarbell
STATSD_URL=statsd://stats.tarbell.mediacloud.org

# TEMP! set registry differently based on BRANCH?!
# Pushing to a local registry for now, while in dev loop.
WORKER_IMAGE_REGISTRY=localhost:5000

WORKER_IMAGE_NAME=indexer-worker

# set DEPLOY_TIME, check remotes up to date
case "$BRANCH" in
prod|staging)
    DEPLOY_TYPE="$BRANCH"

    # check if corresponding branch in mediacloud acct up to date

    # get remote for mediacloud account
    # ONLY match ssh remote, since will want to push tag.
    MCREMOTE=$(git remote -v | awk '/github\.com:mediacloud\// { print $1; exit }')
    if [ "x$MCREMOTE" = x ]; then
	echo could not find an ssh git remote for mediacloud org repo
	exit 1
    fi

    # XXX need "git fetch" to be sure of remote status?
    # check if MCREMOTE up to date.
    if git diff --quiet $BRANCH $MCREMOTE/$BRANCH --; then
	echo "$MCREMOTE $BRANCH branch up to date."
    else
	# pushing to mediacloud repo should NOT be optional
	# for production or staging!!!
	dirty "$MCREMOTE $BRANCH branch not up to date. run 'git push' first!!"
    fi
    # push tag back to JUST github mediacloud branch
    # (might be "origin", might not)
    PUSH_TAG_TO="$MCREMOTE"
    ;;
*)
    DEPLOY_TYPE=dev
    STATSD_REALM=$LOGIN_USER
    # check if origin (ie; user github fork) not up to date
    # XXX need "git fetch" to be sure of remote status?
    if git diff --quiet origin/$BRANCH --; then
	echo "origin/$BRANCH up to date"
    else
	dirty "origin/$BRANCH not up to date.  push!"
    fi
    ;;
esac

DATE_TIME=$(date -u '+%F-%H-%M-%S')
TAG=$DATE_TIME-$HOSTNAME-$BRANCH
case $DEPLOY_TYPE in
prod)
    STACK_NAME=$BASE_STACK_NAME
    ELASTIC_NUM_NODES=3
    PLACEMENT_CONSTRAINTS=1
    # rss-fetcher extracts package version and uses that for tag,
    # refusing to deploy if tag already exists.
    TAG=$DATE_TIME-$BRANCH
    ;;
staging)
    STACK_NAME=staging-$BASE_STACK_NAME
    ;;
dev)
    STACK_NAME=${LOGIN_USER}-$BASE_STACK_NAME
    ;;
esac

WORKER_IMAGE_TAG=$TAG
WORKER_IMAGE_FULL=$WORKER_IMAGE_REGISTRY/$WORKER_IMAGE_NAME:$WORKER_IMAGE_TAG

# base on stack name, if needed??
NETWORK_NAME=story-indexer

# base on stack name, if needed??
ELASTIC_CLUSTER_NAME=mc_elasticsearch

# some commands require docker-compose.yml in the current working directory:
cd $SCRIPT_DIR

echo creating docker-compose.yml
# NOTE! All variables (lower_case) in sorted order,
# set from shell UPPER_CASE shell variables of the same name.
(
  echo '# generated by jinja2: EDITING IS FUTILE'
  echo '# edit docker-compose.yml.j2 and run deploy.sh'
  if [ "x$DEBUG" != x ]; then
      # display jinja2 command:
      set -x
  fi
  # NOTE! COULD pass -Ddeploy_type=$DEPLOY_TYPE, but would rather
  # pass multiple variables that effect specific outcomes
  # (keep decision making in this file, and not template;
  #  don't ifdef based on platform name, but on features)

  # from jinja2-cli package:
  jinja2 \
      -Delastic_cluster_name=$ELASTIC_CLUSTER_NAME \
      -Delastic_num_nodes=$ELASTIC_NUM_NODES \
      -Dfetcher_num_batches=$FETCHER_NUM_BATCHES \
      -Dnetwork_name=$NETWORK_NAME \
      -Dplacement_constraints=$PLACEMENT_CONSTRAINTS \
      -Dstack_name=$STACK_NAME \
      -Dstatsd_realm=$STATSD_REALM \
      -Dstatsd_url=$STATSD_URL \
      -Dworker_image_full=$WORKER_IMAGE_FULL \
      -Dworker_image_name=$WORKER_IMAGE_NAME \
      docker-compose.yml.j2
) > docker-compose.yml.new
STATUS=$?
if [ $STATUS != 0 ]; then
    echo "jinja2 error: $STATUS" 1>&2
    exit 2
fi
mv -f docker-compose.yml.new docker-compose.yml

echo "checking docker-compose.yml syntax" 1>&2
rm -f docker-compose.yml.dump
docker stack config -c docker-compose.yml > docker-compose.yml.dump
STATUS=$?
if [ $STATUS != 0 ]; then
    echo "docker stack config status: $STATUS" 1>&2
    # here with old version of docker? try to continue...
    #exit 3
else
    echo "output (with merges expanded) in docker-compose.yml.dump" 1>&2
fi

# XXX check if on suitable server (right stack) for prod/staging??

# XXX display all commits not currently deployed?
echo "Last commit:"
git log -n1

if [ "x$NO_ACTION" != x ]; then
    echo 'dry run: quitting' 1>&2
    exit 0
fi

echo ''
echo -n "Deploy branch $BRANCH as stack $STACK_NAME? [no] "
read CONFIRM
case "$CONFIRM" in
[yY]|[yY][eE][sS]) ;;
*) echo '[cancelled]'; exit;;
esac

if [ "x$BRANCH" = xprod ]; then
    # XXX check if pushed to $MCREMOTE?? for staging too??

    echo -n "This is production! Type YES to confirm: "
    read CONFIRM
    if [ "x$CONFIRM" != 'xYES' ]; then
       echo '[cancelled]'
       exit
    fi
fi

echo ''
echo adding local git tag $TAG
git tag $TAG
# XXX check status?

# NOTE: push will complain if you (developer) switch branches
# (or your branch has been perturbed upstream, ie; by a force push)
# so add script option to enable --force to push to dokku git repo?

echo "================"

# push tag to upstream repos
for REMOTE in $PUSH_TAG_TO; do
    echo pushing git tag $TAG to $REMOTE
    git push $REMOTE $TAG
    # XXX check status?
    echo "================"
done

echo compose build:
docker compose build
STATUS=$?
if [ $STATUS != 0 ]; then
    echo docker compose build failed: $STATUS 1>&2
    exit 1
fi

echo docker compose push:
docker compose push
STATUS=$?
if [ $STATUS != 0 ]; then
    echo docker compose build failed: $STATUS 1>&2
    exit 1
fi

echo docker stack deploy:
docker stack deploy -c docker-compose.yml $STACK_NAME
STATUS=$?
if [ $STATUS != 0 ]; then
    echo docker stack deploy failed: $STATUS 1>&2
    exit 1
fi

# keep (private) record of deploys:
echo "$DATE_TIME $HOSTNAME $STACK_NAME $REMOTE $TAG" >> deploy.log
# XXX chown to LOGIN_USER?
